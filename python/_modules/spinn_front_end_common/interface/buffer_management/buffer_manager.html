
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spinn_front_end_common.interface.buffer_management.buffer_manager &#8212; SpiNNFrontEndCommon  documentation</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/sphinxdoc.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SpiNNFrontEndCommon  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spinn_front_end_common.interface.buffer_management.buffer_manager</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spinn_front_end_common.interface.buffer_management.buffer_manager</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2017-2019 The University of Manchester</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.log</span> <span class="kn">import</span> <span class="n">FormatAdapter</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.ordered_set</span> <span class="kn">import</span> <span class="n">OrderedSet</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.progress_bar</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">spinn_utilities.timer</span> <span class="kn">import</span> <span class="n">Timer</span>
<span class="kn">from</span> <span class="nn">spinnman.constants</span> <span class="kn">import</span> <span class="n">UDP_MESSAGE_MAX_SIZE</span>
<span class="kn">from</span> <span class="nn">spinnman.connections.udp_packet_connections</span> <span class="kn">import</span> <span class="n">EIEIOConnection</span>
<span class="kn">from</span> <span class="nn">spinnman.messages.eieio.command_messages</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">EIEIOCommandMessage</span><span class="p">,</span> <span class="n">StopRequests</span><span class="p">,</span> <span class="n">SpinnakerRequestBuffers</span><span class="p">,</span>
    <span class="n">HostSendSequencedData</span><span class="p">,</span> <span class="n">EventStopRequest</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinnman.utilities</span> <span class="kn">import</span> <span class="n">utility_functions</span>
<span class="kn">from</span> <span class="nn">spinnman.messages.sdp</span> <span class="kn">import</span> <span class="n">SDPHeader</span><span class="p">,</span> <span class="n">SDPMessage</span><span class="p">,</span> <span class="n">SDPFlag</span>
<span class="kn">from</span> <span class="nn">spinnman.messages.eieio</span> <span class="kn">import</span> <span class="n">EIEIOType</span>
<span class="kn">from</span> <span class="nn">spinnman.messages.eieio.data_messages</span> <span class="kn">import</span> <span class="n">EIEIODataMessage</span>
<span class="kn">from</span> <span class="nn">data_specification.constants</span> <span class="kn">import</span> <span class="n">BYTES_PER_WORD</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.constants</span> <span class="kn">import</span> <span class="n">SDP_PORTS</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">BufferableRegionTooSmall</span><span class="p">,</span> <span class="n">SpinnFrontEndException</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.helpful_functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">locate_memory_region_for_placement</span><span class="p">,</span> <span class="n">locate_extra_monitor_mc_receiver</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.utilities.globals_variables</span> <span class="kn">import</span> <span class="n">get_simulator</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.interface.buffer_management.storage_objects</span> \
    <span class="kn">import</span> <span class="p">(</span><span class="n">BuffersSentDeque</span><span class="p">,</span> <span class="n">BufferedReceivingData</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">spinn_front_end_common.interface.buffer_management.buffer_models</span> \
    <span class="kn">import</span> <span class="nn">AbstractReceiveBuffersToHost</span>
<span class="kn">from</span> <span class="nn">.recording_utilities</span> <span class="kn">import</span> <span class="n">get_recording_header_size</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">FormatAdapter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">))</span>

<span class="c1"># The minimum size of any message - this is the headers plus one entry</span>
<span class="n">_MIN_MESSAGE_SIZE</span> <span class="o">=</span> <span class="n">EIEIODataMessage</span><span class="o">.</span><span class="n">min_packet_length</span><span class="p">(</span>
    <span class="n">eieio_type</span><span class="o">=</span><span class="n">EIEIOType</span><span class="o">.</span><span class="n">KEY_32_BIT</span><span class="p">,</span> <span class="n">is_timestamp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># The number of bytes in each key to be sent</span>
<span class="n">_N_BYTES_PER_KEY</span> <span class="o">=</span> <span class="n">EIEIOType</span><span class="o">.</span><span class="n">KEY_32_BIT</span><span class="o">.</span><span class="n">key_bytes</span>  <span class="c1"># @UndefinedVariable</span>

<span class="n">_SDP_MAX_PACKAGE_SIZE</span> <span class="o">=</span> <span class="mi">272</span>

<span class="n">TRAFFIC_IDENTIFIER</span> <span class="o">=</span> <span class="s2">&quot;BufferTraffic&quot;</span>

<span class="n">VERIFY</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">_RecordingRegion</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">LittleEndianStructure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Recording Region data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># Space available for recording</span>
        <span class="p">(</span><span class="s2">&quot;space&quot;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">),</span>
        <span class="c1"># The size of the recording region</span>
        <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">,</span> <span class="mi">31</span><span class="p">),</span>
        <span class="c1"># Whether any data is missing</span>
        <span class="p">(</span><span class="s2">&quot;missing&quot;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="c1"># The address of the data</span>
        <span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">)</span>
    <span class="p">]</span>


<div class="viewcode-block" id="BufferManager"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager">[docs]</a><span class="k">class</span> <span class="nc">BufferManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Manager of send buffers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># placements object</span>
        <span class="s2">&quot;_placements&quot;</span><span class="p">,</span>

        <span class="c1"># list of tags</span>
        <span class="s2">&quot;_tags&quot;</span><span class="p">,</span>

        <span class="c1"># SpiNNMan instance</span>
        <span class="s2">&quot;_transceiver&quot;</span><span class="p">,</span>

        <span class="c1"># Set of (ip_address, port) that are being listened to for the tags</span>
        <span class="s2">&quot;_seen_tags&quot;</span><span class="p">,</span>

        <span class="c1"># Set of vertices with buffers to be sent</span>
        <span class="s2">&quot;_sender_vertices&quot;</span><span class="p">,</span>

        <span class="c1"># Dictionary of sender vertex -&gt; buffers sent</span>
        <span class="s2">&quot;_sent_messages&quot;</span><span class="p">,</span>

        <span class="c1"># storage area for received data from cores</span>
        <span class="s2">&quot;_received_data&quot;</span><span class="p">,</span>

        <span class="c1"># Lock to avoid multiple messages being processed at the same time</span>
        <span class="s2">&quot;_thread_lock_buffer_out&quot;</span><span class="p">,</span>

        <span class="c1"># Lock to avoid multiple messages being processed at the same time</span>
        <span class="s2">&quot;_thread_lock_buffer_in&quot;</span><span class="p">,</span>

        <span class="c1"># bool flag</span>
        <span class="s2">&quot;_finished&quot;</span><span class="p">,</span>

        <span class="c1"># listener port</span>
        <span class="s2">&quot;_listener_port&quot;</span><span class="p">,</span>

        <span class="c1"># the extra monitor cores which support faster data extraction</span>
        <span class="s2">&quot;_extra_monitor_cores&quot;</span><span class="p">,</span>

        <span class="c1"># the extra_monitor to Ethernet connection map</span>
        <span class="s2">&quot;_packet_gather_cores_to_ethernet_connection_map&quot;</span><span class="p">,</span>

        <span class="c1"># monitor cores via chip ID</span>
        <span class="s2">&quot;_extra_monitor_cores_by_chip&quot;</span><span class="p">,</span>

        <span class="c1"># fixed routes, used by the speed up functionality for reports</span>
        <span class="s2">&quot;_fixed_routes&quot;</span><span class="p">,</span>

        <span class="c1"># machine object</span>
        <span class="s2">&quot;_machine&quot;</span><span class="p">,</span>

        <span class="c1"># flag for what data extraction to use</span>
        <span class="s2">&quot;_uses_advanced_monitors&quot;</span><span class="p">,</span>

        <span class="c1"># Support class to help call Java</span>
        <span class="s2">&quot;_java_caller&quot;</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">extra_monitor_cores</span><span class="p">,</span>
                 <span class="n">packet_gather_cores_to_ethernet_connection_map</span><span class="p">,</span>
                 <span class="n">extra_monitor_to_chip_mapping</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="n">fixed_routes</span><span class="p">,</span>
                 <span class="n">uses_advanced_monitors</span><span class="p">,</span> <span class="n">report_folder</span><span class="p">,</span> <span class="n">java_caller</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            The placements of the vertices</span>
<span class="sd">        :param ~pacman.model.tags.Tags tags: The tags assigned to the vertices</span>
<span class="sd">        :param ~spinnman.transceiver.Transceiver transceiver:</span>
<span class="sd">            The transceiver to use for sending and receiving information</span>
<span class="sd">        :param list(ExtraMonitorSupportMachineVertex) extra_monitor_cores:</span>
<span class="sd">            The monitors.</span>
<span class="sd">        :param packet_gather_cores_to_ethernet_connection_map:</span>
<span class="sd">            mapping of cores to the gatherer vertex placed on them</span>
<span class="sd">        :type packet_gather_cores_to_ethernet_connection_map:</span>
<span class="sd">            dict(tuple(int,int), DataSpeedUpPacketGatherMachineVertex)</span>
<span class="sd">        :param extra_monitor_to_chip_mapping:</span>
<span class="sd">        :type extra_monitor_to_chip_mapping:</span>
<span class="sd">            dict(tuple(int,int),ExtraMonitorSupportMachineVertex)</span>
<span class="sd">        :param ~spinn_machine.Machine machine:</span>
<span class="sd">        :param fixed_routes:</span>
<span class="sd">        :type fixed_routes: dict(tuple(int,int),~spinn_machine.FixedRouteEntry)</span>
<span class="sd">        :param bool uses_advanced_monitors:</span>
<span class="sd">        :param str report_folder:</span>
<span class="sd">            The directory for reports which includes the file to use as an SQL</span>
<span class="sd">            database.</span>
<span class="sd">        :param JavaCaller java_caller:</span>
<span class="sd">            Support class to call Java, or ``None`` to use Python</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_placements</span> <span class="o">=</span> <span class="n">placements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span> <span class="o">=</span> <span class="n">tags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span> <span class="o">=</span> <span class="n">transceiver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extra_monitor_cores</span> <span class="o">=</span> <span class="n">extra_monitor_cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_packet_gather_cores_to_ethernet_connection_map</span> <span class="o">=</span> \
            <span class="n">packet_gather_cores_to_ethernet_connection_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extra_monitor_cores_by_chip</span> <span class="o">=</span> <span class="n">extra_monitor_to_chip_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_routes</span> <span class="o">=</span> <span class="n">fixed_routes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_machine</span> <span class="o">=</span> <span class="n">machine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uses_advanced_monitors</span> <span class="o">=</span> <span class="n">uses_advanced_monitors</span>

        <span class="c1"># Set of (ip_address, port) that are being listened to for the tags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seen_tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Set of vertices with buffers to be sent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sender_vertices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Dictionary of sender vertex -&gt; buffers sent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sent_messages</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># storage area for received data from cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span> <span class="o">=</span> <span class="n">BufferedReceivingData</span><span class="p">(</span><span class="n">report_folder</span><span class="p">)</span>

        <span class="c1"># Lock to avoid multiple messages being processed at the same time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_thread_lock_buffer_out</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_thread_lock_buffer_in</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">RLock</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_listener_port</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span> <span class="o">=</span> <span class="n">java_caller</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span><span class="o">.</span><span class="n">set_machine</span><span class="p">(</span><span class="n">machine</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span><span class="o">.</span><span class="n">set_report_folder</span><span class="p">(</span><span class="n">report_folder</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_advanced_monitors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span><span class="o">.</span><span class="n">set_advanced_monitors</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_placements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_extra_monitor_cores_by_chip</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_packet_gather_cores_to_ethernet_connection_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_request_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transceiver</span><span class="p">,</span> <span class="n">placement_x</span><span class="p">,</span> <span class="n">placement_y</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
                      <span class="n">length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Uses the extra monitor cores for data extraction.</span>

<span class="sd">        :param ~spinnman.transceiver.Transceiver transceiver:</span>
<span class="sd">            the spinnman interface</span>
<span class="sd">        :param int placement_x:</span>
<span class="sd">            the placement x coord where data is to be extracted from</span>
<span class="sd">        :param int placement_y:</span>
<span class="sd">            the placement y coord where data is to be extracted from</span>
<span class="sd">        :param int address: the memory address to start at</span>
<span class="sd">        :param int length: the number of bytes to extract</span>
<span class="sd">        :return: data as a byte array</span>
<span class="sd">        :rtype: bytearray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-arguments</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_advanced_monitors</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transceiver</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span>
                <span class="n">placement_x</span><span class="p">,</span> <span class="n">placement_y</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

        <span class="c1"># Round to word boundaries</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="n">address</span> <span class="o">%</span> <span class="n">BYTES_PER_WORD</span>
        <span class="n">address</span> <span class="o">-=</span> <span class="n">initial</span>
        <span class="n">length</span> <span class="o">+=</span> <span class="n">initial</span>
        <span class="n">final</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTES_PER_WORD</span> <span class="o">-</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="n">BYTES_PER_WORD</span><span class="p">))</span> <span class="o">%</span> <span class="n">BYTES_PER_WORD</span>
        <span class="n">length</span> <span class="o">+=</span> <span class="n">final</span>

        <span class="n">sender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_monitor_cores_by_chip</span><span class="p">[</span><span class="n">placement_x</span><span class="p">,</span> <span class="n">placement_y</span><span class="p">]</span>
        <span class="n">receiver</span> <span class="o">=</span> <span class="n">locate_extra_monitor_mc_receiver</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_machine</span><span class="p">,</span> <span class="n">placement_x</span><span class="p">,</span> <span class="n">placement_y</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_packet_gather_cores_to_ethernet_connection_map</span><span class="p">)</span>
        <span class="n">extra_mon_data</span> <span class="o">=</span> <span class="n">receiver</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
            <span class="n">sender</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">sender</span><span class="p">),</span>
            <span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_routes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">VERIFY</span><span class="p">:</span>
            <span class="n">txrx_data</span> <span class="o">=</span> <span class="n">transceiver</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span>
                <span class="n">placement_x</span><span class="p">,</span> <span class="n">placement_y</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verify_data</span><span class="p">(</span><span class="n">extra_mon_data</span><span class="p">,</span> <span class="n">txrx_data</span><span class="p">)</span>

        <span class="c1"># If we rounded to word boundaries, strip the padding junk</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">and</span> <span class="n">final</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extra_mon_data</span><span class="p">[</span><span class="n">initial</span><span class="p">:</span><span class="o">-</span><span class="n">final</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">initial</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extra_mon_data</span><span class="p">[</span><span class="n">initial</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">final</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extra_mon_data</span><span class="p">[:</span><span class="o">-</span><span class="n">final</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extra_mon_data</span>

    <span class="k">def</span> <span class="nf">_verify_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extra_mon_data</span><span class="p">,</span> <span class="n">txrx_data</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">extra_mon_element</span><span class="p">,</span> <span class="n">txrx_element</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">extra_mon_data</span><span class="p">,</span> <span class="n">txrx_data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">extra_mon_element</span> <span class="o">!=</span> <span class="n">txrx_element</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;WRONG (at index </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_receive_buffer_command_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">packet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Handle an EIEIO command message for the buffers.</span>

<span class="sd">        :param packet: The EIEIO message received</span>
<span class="sd">        :type packet:</span>
<span class="sd">            ~spinnman.messages.eieio.command_messages.EIEIOCommandMessage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=broad-except</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">SpinnakerRequestBuffers</span><span class="p">):</span>
            <span class="c1"># noinspection PyBroadException</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__request_buffers</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;problem when sending messages&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">packet</span><span class="p">,</span> <span class="n">EIEIOCommandMessage</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;The command packet is invalid for buffer management: &quot;</span>
                <span class="s2">&quot;command ID </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">packet</span><span class="o">.</span><span class="n">eieio_header</span><span class="o">.</span><span class="n">command</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;The command packet is invalid for buffer management&quot;</span><span class="p">)</span>

    <span class="c1"># Factored out of receive_buffer_command_message to keep code readable</span>
    <span class="k">def</span> <span class="nf">__request_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">packet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param packet: The EIEIO message received</span>
<span class="sd">        :type packet:</span>
<span class="sd">            ~spinnman.messages.eieio.command_messages.SpinnakerRequestBuffers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread_lock_buffer_in</span><span class="p">:</span>
                <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_placements</span><span class="o">.</span><span class="n">get_vertex_on_processor</span><span class="p">(</span>
                    <span class="n">packet</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">packet</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">packet</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender_vertices</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_send_messages</span><span class="p">(</span>
                        <span class="n">packet</span><span class="o">.</span><span class="n">space_available</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span>
                        <span class="n">packet</span><span class="o">.</span><span class="n">region_id</span><span class="p">,</span> <span class="n">packet</span><span class="o">.</span><span class="n">sequence_no</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_create_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~spinn_machine.tags.IPTag tag:</span>
<span class="sd">        :rtype: ~spinnman.connections.udp_packet_connections.EIEIOConnection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="o">.</span><span class="n">register_udp_listener</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_receive_buffer_command_message</span><span class="p">,</span> <span class="n">EIEIOConnection</span><span class="p">,</span>
            <span class="n">local_port</span><span class="o">=</span><span class="n">tag</span><span class="o">.</span><span class="n">port</span><span class="p">,</span> <span class="n">local_host</span><span class="o">=</span><span class="n">tag</span><span class="o">.</span><span class="n">ip_address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seen_tags</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">tag</span><span class="o">.</span><span class="n">ip_address</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">local_port</span><span class="p">))</span>
        <span class="n">utility_functions</span><span class="o">.</span><span class="n">send_port_trigger_message</span><span class="p">(</span>
            <span class="n">connection</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">board_address</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Listening for packets using tag </span><span class="si">{}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">tag</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">local_ip_address</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">local_port</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">_add_buffer_listeners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add listeners for buffered data for the given vertex</span>

<span class="sd">        :param ~pacman.model.graphs.machine.MachineVertex vertex:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find a tag for receiving buffer data</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="o">.</span><span class="n">get_ip_tags_for_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># locate tag associated with the buffer manager traffic</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tag</span><span class="o">.</span><span class="n">traffic_identifier</span> <span class="o">==</span> <span class="n">TRAFFIC_IDENTIFIER</span><span class="p">:</span>
                    <span class="c1"># If the tag port is not assigned create a connection and</span>
                    <span class="c1"># assign the port.  Note that this *should* update the</span>
                    <span class="c1"># port number in any tags being shared.</span>
                    <span class="k">if</span> <span class="n">tag</span><span class="o">.</span><span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># If connection already setup, ensure subsequent</span>
                        <span class="c1"># boards use same listener port in their tag</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listener_port</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_connection</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                            <span class="n">tag</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">local_port</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_listener_port</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">local_port</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">tag</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_listener_port</span>

                    <span class="c1"># In case we have tags with different specified ports,</span>
                    <span class="c1"># also allow the tag to be created here</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">ip_address</span><span class="p">,</span> <span class="n">tag</span><span class="o">.</span><span class="n">port</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seen_tags</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_create_connection</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>

<div class="viewcode-block" id="BufferManager.add_receiving_vertex"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.add_receiving_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">add_receiving_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a vertex into the managed list for vertices which require\</span>
<span class="sd">            buffers to be received from them during runtime.</span>

<span class="sd">        :param AbstractReceiveBuffersToHost vertex: the vertex to be managed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_buffer_listeners</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span></div>

<div class="viewcode-block" id="BufferManager.add_sender_vertex"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.add_sender_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">add_sender_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Add a vertex into the managed list for vertices which require\</span>
<span class="sd">            buffers to be sent to them during runtime.</span>

<span class="sd">        :param AbstractSendsBuffersFromHost vertex: the vertex to be managed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sender_vertices</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_buffer_listeners</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span></div>

<div class="viewcode-block" id="BufferManager.load_initial_buffers"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.load_initial_buffers">[docs]</a>    <span class="k">def</span> <span class="nf">load_initial_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Load the initial buffers for the senders using memory writes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total_data</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender_vertices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_regions</span><span class="p">():</span>
                <span class="n">total_data</span> <span class="o">+=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_region_buffer_size</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>

        <span class="n">progress</span> <span class="o">=</span> <span class="n">ProgressBar</span><span class="p">(</span><span class="n">total_data</span><span class="p">,</span> <span class="s2">&quot;Loading buffers&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender_vertices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_regions</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_send_initial_messages</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">progress</span><span class="p">)</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">end</span><span class="p">()</span></div>

<div class="viewcode-block" id="BufferManager.reset"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resets the buffered regions to start transmitting from the\</span>
<span class="sd">            beginning of its expected regions and clears the buffered out\</span>
<span class="sd">            data files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># rewind buffered in</span>
        <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender_vertices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_regions</span><span class="p">():</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">rewind</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BufferManager.resume"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.resume">[docs]</a>    <span class="k">def</span> <span class="nf">resume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Resets any data structures needed before starting running again.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># update the received data items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">resume</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BufferManager.clear_recorded_data"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.clear_recorded_data">[docs]</a>    <span class="k">def</span> <span class="nf">clear_recorded_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">recording_region_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Removes the recorded data stored in memory.</span>

<span class="sd">        :param int x: placement x coordinate</span>
<span class="sd">        :param int y: placement y coordinate</span>
<span class="sd">        :param int p: placement p coordinate</span>
<span class="sd">        :param int recording_region_id: the recording region ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">recording_region_id</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_create_message_to_send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a single message to send with the given boundaries.</span>

<span class="sd">        :param int size: The number of bytes available for the whole packet</span>
<span class="sd">        :param AbstractSendsBuffersFromHost vertex:</span>
<span class="sd">            The vertex to get the keys from</span>
<span class="sd">        :param int region: The region of the vertex to get keys from</span>
<span class="sd">        :return: A new message, or None if no keys can be added</span>
<span class="sd">        :rtype: None or ~spinnman.messages.eieio.data_messages.EIEIODataMessage</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If there are no more messages to send, return None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertex</span><span class="o">.</span><span class="n">is_next_timestamp</span><span class="p">(</span><span class="n">region</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Create a new message</span>
        <span class="n">next_timestamp</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_next_timestamp</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">EIEIODataMessage</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">EIEIOType</span><span class="o">.</span><span class="n">KEY_32_BIT</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">next_timestamp</span><span class="p">)</span>

        <span class="c1"># If there is no room for the message, return None</span>
        <span class="k">if</span> <span class="n">message</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">_N_BYTES_PER_KEY</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Add keys up to the limit</span>
        <span class="n">bytes_to_go</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">message</span><span class="o">.</span><span class="n">size</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">bytes_to_go</span> <span class="o">&gt;=</span> <span class="n">_N_BYTES_PER_KEY</span> <span class="ow">and</span>
                <span class="n">vertex</span><span class="o">.</span><span class="n">is_next_key</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">next_timestamp</span><span class="p">)):</span>

            <span class="n">key</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_next_key</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="n">message</span><span class="o">.</span><span class="n">add_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">bytes_to_go</span> <span class="o">-=</span> <span class="n">_N_BYTES_PER_KEY</span>

        <span class="k">return</span> <span class="n">message</span>

    <span class="k">def</span> <span class="nf">_send_initial_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">progress</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Send the initial set of messages.</span>

<span class="sd">        :param AbstractSendsBuffersFromHost vertex:</span>
<span class="sd">            The vertex to get the keys from</span>
<span class="sd">        :param int region: The region to get the keys from</span>
<span class="sd">        :return: A list of messages</span>
<span class="sd">        :rtype: list(~spinnman.messages.eieio.data_messages.EIEIODataMessage)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the vertex load details</span>
        <span class="c1"># region_base_address = self._locate_region_address(region, vertex)</span>
        <span class="n">placement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="n">region_base_address</span> <span class="o">=</span> <span class="n">locate_memory_region_for_placement</span><span class="p">(</span>
            <span class="n">placement</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="p">)</span>

        <span class="c1"># Add packets until out of space</span>
        <span class="n">sent_message</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">bytes_to_go</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_region_buffer_size</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bytes_to_go</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SpinnFrontEndException</span><span class="p">(</span>
                <span class="s2">&quot;The buffer region of </span><span class="si">{}</span><span class="s2"> must be divisible by 2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">vertex</span><span class="p">))</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">is_empty</span><span class="p">(</span><span class="n">region</span><span class="p">):</span>
            <span class="n">sent_message</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_size_of_packet</span> <span class="o">=</span> <span class="n">_MIN_MESSAGE_SIZE</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">is_next_timestamp</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">bytes_to_go</span> <span class="o">&gt;</span> <span class="n">min_size_of_packet</span><span class="p">):</span>
                <span class="n">space_available</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bytes_to_go</span><span class="p">,</span> <span class="n">_SDP_MAX_PACKAGE_SIZE</span><span class="p">)</span>
                <span class="n">next_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_message_to_send</span><span class="p">(</span>
                    <span class="n">space_available</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">next_message</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c1"># Write the message to the memory</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">next_message</span><span class="o">.</span><span class="n">bytestring</span>
                <span class="n">all_data</span> <span class="o">+=</span> <span class="n">data</span>
                <span class="n">sent_message</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Update the positions</span>
                <span class="n">bytes_to_go</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sent_message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BufferableRegionTooSmall</span><span class="p">(</span>
                <span class="s2">&quot;The buffer size </span><span class="si">{}</span><span class="s2"> is too small for any data to be added for&quot;</span>
                <span class="s2">&quot; region </span><span class="si">{}</span><span class="s2"> of vertex </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bytes_to_go</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">vertex</span><span class="p">))</span>

        <span class="c1"># If there are no more messages and there is space, add a stop request</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">vertex</span><span class="o">.</span><span class="n">is_next_timestamp</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">bytes_to_go</span> <span class="o">&gt;=</span> <span class="n">EventStopRequest</span><span class="o">.</span><span class="n">get_min_packet_length</span><span class="p">()):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">EventStopRequest</span><span class="p">()</span><span class="o">.</span><span class="n">bytestring</span>
            <span class="c1"># logger.debug(</span>
            <span class="c1">#    &quot;Writing stop message of {} bytes to {} on {}, {}, {}&quot;.format(</span>
            <span class="c1">#         len(data), hex(region_base_address),</span>
            <span class="c1">#         placement.x, placement.y, placement.p))</span>
            <span class="n">all_data</span> <span class="o">+=</span> <span class="n">data</span>
            <span class="n">bytes_to_go</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sent_messages</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">BuffersSentDeque</span><span class="p">(</span>
                <span class="n">region</span><span class="p">,</span> <span class="n">sent_stop_message</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Do the writing all at once for efficiency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="o">.</span><span class="n">write_memory</span><span class="p">(</span>
            <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">region_base_address</span><span class="p">,</span> <span class="n">all_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_send_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">sequence_no</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Send a set of messages.</span>

<span class="sd">        :param int size:</span>
<span class="sd">        :param AbstractSendsBuffersFromHost vertex:</span>
<span class="sd">        :param int region:</span>
<span class="sd">        :param int sequence_no:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the sent messages for the vertex</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sent_messages</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sent_messages</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="n">BuffersSentDeque</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">sent_messages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sent_messages</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span>

        <span class="c1"># If the sequence number is outside the window, return now with no</span>
        <span class="c1"># messages sent</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sent_messages</span><span class="o">.</span><span class="n">update_last_received_sequence_number</span><span class="p">(</span><span class="n">sequence_no</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Remote the existing packets from the size available</span>
        <span class="n">bytes_to_go</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">sent_messages</span><span class="o">.</span><span class="n">messages</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">eieio_data_message</span><span class="p">,</span> <span class="n">EIEIODataMessage</span><span class="p">):</span>
                <span class="n">bytes_to_go</span> <span class="o">-=</span> <span class="n">message</span><span class="o">.</span><span class="n">eieio_data_message</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bytes_to_go</span> <span class="o">-=</span> <span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">eieio_data_message</span>
                                <span class="o">.</span><span class="n">get_min_packet_length</span><span class="p">())</span>

        <span class="c1"># Add messages up to the limits</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">is_next_timestamp</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">sent_messages</span><span class="o">.</span><span class="n">is_full</span> <span class="ow">and</span> <span class="n">bytes_to_go</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="n">space_available</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">bytes_to_go</span><span class="p">,</span>
                <span class="n">UDP_MESSAGE_MAX_SIZE</span> <span class="o">-</span>
                <span class="n">HostSendSequencedData</span><span class="o">.</span><span class="n">get_min_packet_length</span><span class="p">())</span>
            <span class="c1"># logger.debug(</span>
            <span class="c1">#     &quot;Bytes to go {}, space available {}&quot;.format(</span>
            <span class="c1">#         bytes_to_go, space_available))</span>
            <span class="n">next_message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_message_to_send</span><span class="p">(</span>
                <span class="n">space_available</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_message</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">sent_messages</span><span class="o">.</span><span class="n">add_message_to_send</span><span class="p">(</span><span class="n">next_message</span><span class="p">)</span>
            <span class="n">bytes_to_go</span> <span class="o">-=</span> <span class="n">next_message</span><span class="o">.</span><span class="n">size</span>
            <span class="c1"># logger.debug(&quot;Adding additional buffer of {} bytes&quot;.format(</span>
            <span class="c1">#     next_message.size))</span>

        <span class="c1"># If the vertex is empty, send the stop messages if there is space</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sent_messages</span><span class="o">.</span><span class="n">is_full</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">vertex</span><span class="o">.</span><span class="n">is_next_timestamp</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">bytes_to_go</span> <span class="o">&gt;=</span> <span class="n">EventStopRequest</span><span class="o">.</span><span class="n">get_min_packet_length</span><span class="p">()):</span>
            <span class="n">sent_messages</span><span class="o">.</span><span class="n">send_stop_message</span><span class="p">()</span>

        <span class="c1"># If there are no more messages, turn off requests for more messages</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vertex</span><span class="o">.</span><span class="n">is_next_timestamp</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sent_messages</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span>
            <span class="c1"># logger.debug(&quot;Sending stop&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">StopRequests</span><span class="p">())</span>

        <span class="c1"># Send the messages</span>
        <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">sent_messages</span><span class="o">.</span><span class="n">messages</span><span class="p">:</span>
            <span class="c1"># logger.debug(&quot;Sending message with sequence {}&quot;.format(</span>
            <span class="c1">#     message.sequence_no))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_send_request</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_send_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sends a request.</span>

<span class="sd">        :param AbstractSendsBuffersFromHost vertex: The vertex to send to</span>
<span class="sd">        :param message: The message to send</span>
<span class="sd">        :type message:</span>
<span class="sd">            ~spinman.messages.eieio.command_messages.EIEIOCommandMessage</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">placement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_placements</span><span class="o">.</span><span class="n">get_placement_of_vertex</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="n">sdp_header</span> <span class="o">=</span> <span class="n">SDPHeader</span><span class="p">(</span>
            <span class="n">destination_chip_x</span><span class="o">=</span><span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">destination_chip_y</span><span class="o">=</span><span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
            <span class="n">destination_cpu</span><span class="o">=</span><span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">SDPFlag</span><span class="o">.</span><span class="n">REPLY_NOT_EXPECTED</span><span class="p">,</span>
            <span class="n">destination_port</span><span class="o">=</span><span class="n">SDP_PORTS</span><span class="o">.</span><span class="n">INPUT_BUFFERING_SDP_PORT</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">sdp_message</span> <span class="o">=</span> <span class="n">SDPMessage</span><span class="p">(</span><span class="n">sdp_header</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">bytestring</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="o">.</span><span class="n">send_sdp_message</span><span class="p">(</span><span class="n">sdp_message</span><span class="p">)</span>

<div class="viewcode-block" id="BufferManager.stop"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Indicates that the simulation has finished, so no further\</span>
<span class="sd">            outstanding requests need to be processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread_lock_buffer_in</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread_lock_buffer_out</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="BufferManager.get_data_for_placements"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.get_data_for_placements">[docs]</a>    <span class="k">def</span> <span class="nf">get_data_for_placements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">progress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            Where to get the data from.</span>
<span class="sd">        :param progress: How to measure/display the progress.</span>
<span class="sd">        :type progress: ~spinn_utilities.progress_bar.ProgressBar or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span><span class="o">.</span><span class="n">set_placements</span><span class="p">(</span><span class="n">placements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="p">)</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">timer</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread_lock_buffer_out</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_java_caller</span><span class="o">.</span><span class="n">get_all_data</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">progress</span><span class="p">:</span>
                        <span class="n">progress</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uses_advanced_monitors</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__old_get_data_for_placements_with_monitors</span><span class="p">(</span>
                        <span class="n">placements</span><span class="p">,</span> <span class="n">progress</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__old_get_data_for_placements</span><span class="p">(</span><span class="n">placements</span><span class="p">,</span> <span class="n">progress</span><span class="p">)</span>
        <span class="n">get_simulator</span><span class="p">()</span><span class="o">.</span><span class="n">add_extraction_timing</span><span class="p">(</span><span class="n">timer</span><span class="o">.</span><span class="n">measured_interval</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__old_get_data_for_placements_with_monitors</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">progress</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            Where to get the data from.</span>
<span class="sd">        :param progress: How to measure/display the progress.</span>
<span class="sd">        :type progress: ~spinn_utilities.progress_bar.ProgressBar or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># locate receivers</span>
        <span class="n">receivers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedSet</span><span class="p">(</span>
            <span class="n">locate_extra_monitor_mc_receiver</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_machine</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_packet_gather_cores_to_ethernet_connection_map</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">placement</span> <span class="ow">in</span> <span class="n">placements</span><span class="p">))</span>

        <span class="c1"># update transaction id from the machine for all extra monitors</span>
        <span class="k">for</span> <span class="n">extra_mon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_monitor_cores</span><span class="p">:</span>
            <span class="n">extra_mon</span><span class="o">.</span><span class="n">update_transaction_id_from_machine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="p">)</span>

        <span class="c1"># Ugly, to avoid an import loop...</span>
        <span class="k">with</span> <span class="n">receivers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">streaming</span><span class="p">(</span>
                <span class="n">receivers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_monitor_cores</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_placements</span><span class="p">):</span>
            <span class="c1"># get data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__old_get_data_for_placements</span><span class="p">(</span><span class="n">placements</span><span class="p">,</span> <span class="n">progress</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__old_get_data_for_placements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placements</span><span class="p">,</span> <span class="n">progress</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param ~pacman.model.placements.Placements placements:</span>
<span class="sd">            Where to get the data from.</span>
<span class="sd">        :param progress: How to measure/display the progress.</span>
<span class="sd">        :type progress: ~spinn_utilities.progress_bar.ProgressBar or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get data</span>
        <span class="k">for</span> <span class="n">placement</span> <span class="ow">in</span> <span class="n">placements</span><span class="p">:</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">placement</span><span class="o">.</span><span class="n">vertex</span>
            <span class="k">for</span> <span class="n">recording_region_id</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_recorded_region_ids</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_retreive_by_placement</span><span class="p">(</span><span class="n">placement</span><span class="p">,</span> <span class="n">recording_region_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

<div class="viewcode-block" id="BufferManager.get_data_by_placement"><a class="viewcode-back" href="../../../../spinn_front_end_common.interface.buffer_management.html#spinn_front_end_common.interface.buffer_management.BufferManager.get_data_by_placement">[docs]</a>    <span class="k">def</span> <span class="nf">get_data_by_placement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">recording_region_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the data container for all the data retrieved\</span>
<span class="sd">            during the simulation from a specific region area of a core.</span>

<span class="sd">        :param ~pacman.model.placements.Placement placement:</span>
<span class="sd">            the placement to get the data from</span>
<span class="sd">        :param int recording_region_id: desired recording data region</span>
<span class="sd">        :return: an array contained all the data received during the</span>
<span class="sd">            simulation, and a flag indicating if any data was missing</span>
<span class="sd">        :rtype: tuple(bytearray, bool)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that any transfers in progress are complete first</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">placement</span><span class="o">.</span><span class="n">vertex</span><span class="p">,</span> <span class="n">AbstractReceiveBuffersToHost</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;vertex </span><span class="si">{}</span><span class="s2"> does not implement AbstractReceiveBuffersToHost &quot;</span>
                <span class="s2">&quot;so no data read&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">placement</span><span class="o">.</span><span class="n">vertex</span><span class="p">))</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread_lock_buffer_out</span><span class="p">:</span>
            <span class="c1"># data flush has been completed - return appropriate data</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">get_region_data</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">recording_region_id</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_retreive_by_placement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placement</span><span class="p">,</span> <span class="n">region</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve the data for a vertex; must be locked first.</span>

<span class="sd">        :param ~pacman.model.placements.Placement placement:</span>
<span class="sd">            the placement to get the data from</span>
<span class="sd">        :param int recording_region_id: desired recording data region</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Has the region information been read</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">has_region_information</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">):</span>

            <span class="n">addr</span> <span class="o">=</span> <span class="n">placement</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">get_recording_region_base_address</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_region_information</span><span class="p">(</span>
                <span class="n">addr</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>

        <span class="c1"># Read the data if not already received</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">is_data_from_region_flushed</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">region</span><span class="p">):</span>

            <span class="c1"># Now read the data and store it</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">get_region_information</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_request_data</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">store_data_in_region_buffer</span><span class="p">(</span>
                <span class="n">placement</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">placement</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_region_information</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the recording information from all regions of a core</span>

<span class="sd">        :param addr: The recording region base address</span>
<span class="sd">        :param x: The x-coordinate of the chip containing the data</span>
<span class="sd">        :param y: The y-coordinate of the chip containing the data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_regions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="o">.</span><span class="n">read_word</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
        <span class="n">n_bytes</span> <span class="o">=</span> <span class="n">get_recording_header_size</span><span class="p">(</span><span class="n">n_regions</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transceiver</span><span class="o">.</span><span class="n">read_memory</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">BYTES_PER_WORD</span><span class="p">,</span> <span class="n">n_bytes</span> <span class="o">-</span> <span class="n">BYTES_PER_WORD</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">_RecordingRegion</span> <span class="o">*</span> <span class="n">n_regions</span>
        <span class="n">regions</span> <span class="o">=</span> <span class="n">data_type</span><span class="o">.</span><span class="n">from_buffer_copy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">sizes_and_addresses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">missing</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">regions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_received_data</span><span class="o">.</span><span class="n">store_region_information</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">sizes_and_addresses</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sender_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The vertices which are buffered.</span>

<span class="sd">        :rtype: iterable(AbstractSendsBuffersFromHost)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sender_vertices</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SpiNNFrontEndCommon  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">spinn_front_end_common.interface.buffer_management.buffer_manager</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.3.
    </div>
  </body>
</html>